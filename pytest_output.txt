============================= test session starts =============================
platform win32 -- Python 3.12.2, pytest-7.1.3, pluggy-1.6.0 -- C:\Yandex\sprint3\django_sprint3\venv\Scripts\python.exe
django: settings: blogicum.settings (from ini)
rootdir: C:\Yandex\sprint3\django_sprint3, configfile: pytest.ini, testpaths: tests/
plugins: Faker-12.0.1, django-4.5.2
collecting ... collected 82 items

tests/test_category_page_views.py::test_category_page ERROR              [  1%]
tests/test_category_page_views.py::test_category_page_check_context_keys[title] ERROR [  2%]
tests/test_category_page_views.py::test_category_page_check_context_keys[key1] ERROR [  3%]
tests/test_category_page_views.py::test_category_page_check_context_keys[key2] ERROR [  4%]
tests/test_category_page_views.py::test_category_page_check_context_keys[key3] ERROR [  6%]
tests/test_category_page_views.py::test_category_page_category_unpublished ERROR [  7%]
tests/test_category_page_views.py::test_category_page_posts_unpublished ERROR [  8%]
tests/test_category_page_views.py::test_category_page_pub_date_later_today ERROR [  9%]
tests/test_category_page_views.py::test_category_page_posts_with_location ERROR [ 10%]
tests/test_category_page_views.py::test_category_page_posts_with_unpublished_locations ERROR [ 12%]
tests/test_category_page_views.py::test_many_posts_on_category_page ERROR [ 13%]
tests/test_category_page_views.py::test_no_other_posts_on_category_page ERROR [ 14%]
tests/test_pageapp_views.py::test_pageapp_views[about] FAILED            [ 15%]
tests/test_pageapp_views.py::test_pageapp_views[rules] FAILED            [ 17%]
tests/test_post_detail_views.py::test_posts_page_pk_published_location ERROR [ 18%]
tests/test_post_detail_views.py::test_posts_page_pk_unpublished_location ERROR [ 19%]
tests/test_post_detail_views.py::test_posts_page_pk_post_doesnt_exists PASSED [ 20%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[title] ERROR [ 21%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[text] ERROR [ 23%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key2] ERROR [ 24%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key3] ERROR [ 25%]
tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key4] ERROR [ 26%]
tests/test_post_detail_views.py::test_posts_page_pk_unpublished_post PASSED [ 28%]
tests/test_post_detail_views.py::test_posts_page_pk_pub_date_later_today PASSED [ 29%]
tests/test_post_detail_views.py::test_posts_page_pk_category_unpublished PASSED [ 30%]
tests/test_post_detail_views.py::test_posts_page_pk_post_with_published_location_and_category ERROR [ 31%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[title-CharField-params0] <- tests\conftest.py PASSED [ 32%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[text-TextField-params1] <- tests\conftest.py PASSED [ 34%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[pub_date-DateTimeField-params2] <- tests\conftest.py PASSED [ 35%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[author-ForeignKey-params3] <- tests\conftest.py PASSED [ 36%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[location-ForeignKey-params4] <- tests\conftest.py PASSED [ 37%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[category-ForeignKey-params5] <- tests\conftest.py PASSED [ 39%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[is_published-BooleanField-params6] <- tests\conftest.py PASSED [ 40%]
tests/test_post_model.py::TestPostModelAttrs::test_model_attrs[created_at-DateTimeField-params7] <- tests\conftest.py PASSED [ 41%]
tests/test_post_model.py::test_author_on_delete PASSED                   [ 42%]
tests/test_post_model.py::test_location_on_delete PASSED                 [ 43%]
tests/test_posts_page_views.py::test_all_unpublished ERROR               [ 45%]
tests/test_posts_page_views.py::test_mixed_published ERROR               [ 46%]
tests/test_posts_page_views.py::test_check_context_keys[title] ERROR     [ 47%]
tests/test_posts_page_views.py::test_check_context_keys[key1] ERROR      [ 48%]
tests/test_posts_page_views.py::test_check_context_keys[key2] ERROR      [ 50%]
tests/test_posts_page_views.py::test_check_context_keys[key3] ERROR      [ 51%]
tests/test_posts_page_views.py::test_category_unpublished ERROR          [ 52%]
tests/test_posts_page_views.py::test_pub_date_later_today ERROR          [ 53%]
tests/test_posts_page_views.py::test_posts_with_published_location ERROR [ 54%]
tests/test_posts_page_views.py::test_posts_with_unpublished_locations ERROR [ 56%]
tests/test_posts_page_views.py::test_many_posts_on_main_page ERROR       [ 57%]
tests/test_admin_page.py::test_admin_register PASSED                     [ 58%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[title-CharField-params0] <- tests\conftest.py PASSED [ 59%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[description-TextField-params1] <- tests\conftest.py PASSED [ 60%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[slug-SlugField-params2] <- tests\conftest.py PASSED [ 62%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[is_published-BooleanField-params3] <- tests\conftest.py PASSED [ 63%]
tests/test_category_model.py::TestCategoryModelAttrs::test_model_attrs[created_at-DateTimeField-params4] <- tests\conftest.py PASSED [ 64%]
tests/test_localization.py::test_rus_localization PASSED                 [ 65%]
tests/test_localization.py::test_blog_in_rus PASSED                      [ 67%]
tests/test_localization.py::test_models_translated[Category-\u043a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f-\u041a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u0438] PASSED [ 68%]
tests/test_localization.py::test_models_translated[Location-\u043c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435-\u041c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u044f] PASSED [ 69%]
tests/test_localization.py::test_models_translated[Post-\u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u044f-\u041f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438] PASSED [ 70%]
tests/test_localization.py::test_models_params_translate[Category-is_published-\u041e\u043f\u0443\u0431\u043b\u0438\u043a\u043e\u0432\u0430\u043d\u043e] PASSED [ 71%]
tests/test_localization.py::test_models_params_translate[Category-title-\u0417\u0430\u0433\u043e\u043b\u043e\u0432\u043e\u043a] PASSED [ 73%]
tests/test_localization.py::test_models_params_translate[Category-slug-\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440] PASSED [ 74%]
tests/test_localization.py::test_models_params_translate[Category-description-\u041e\u043f\u0438\u0441\u0430\u043d\u0438\u0435] PASSED [ 75%]
tests/test_localization.py::test_models_params_translate[Category-created_at-\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043e] PASSED [ 76%]
tests/test_localization.py::test_models_params_translate[Location-name-\u041d\u0430\u0437\u0432\u0430\u043d\u0438\u0435 \u043c\u0435\u0441\u0442\u0430] PASSED [ 78%]
tests/test_localization.py::test_models_params_translate[Location-created_at-\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043e] PASSED [ 79%]
tests/test_localization.py::test_models_params_translate[Location-is_published-\u041e\u043f\u0443\u0431\u043b\u0438\u043a\u043e\u0432\u0430\u043d\u043e] PASSED [ 80%]
tests/test_localization.py::test_models_params_translate[Post-pub_date-\u0414\u0430\u0442\u0430 \u0438 \u0432\u0440\u0435\u043c\u044f \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438] PASSED [ 81%]
tests/test_localization.py::test_models_params_translate[Post-text-\u0422\u0435\u043a\u0441\u0442] PASSED [ 82%]
tests/test_localization.py::test_models_params_translate[Post-author-\u0410\u0432\u0442\u043e\u0440 \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438] PASSED [ 84%]
tests/test_localization.py::test_models_params_translate[Post-category-\u041a\u0430\u0442\u0435\u0433\u043e\u0440\u0438\u044f] PASSED [ 85%]
tests/test_localization.py::test_models_params_translate[Post-location-\u041c\u0435\u0441\u0442\u043e\u043f\u043e\u043b\u043e\u0436\u0435\u043d\u0438\u0435] PASSED [ 86%]
tests/test_localization.py::test_models_params_translate[Post-created_at-\u0414\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u043e] PASSED [ 87%]
tests/test_localization.py::test_models_params_translate[Post-is_published-\u041e\u043f\u0443\u0431\u043b\u0438\u043a\u043e\u0432\u0430\u043d\u043e] PASSED [ 89%]
tests/test_localization.py::test_help_text_translate[Category-is_published-\u0421\u043d\u0438\u043c\u0438\u0442\u0435 \u0433\u0430\u043b\u043e\u0447\u043a\u0443, \u0447\u0442\u043e\u0431\u044b \u0441\u043a\u0440\u044b\u0442\u044c \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u044e.] PASSED [ 90%]
tests/test_localization.py::test_help_text_translate[Category-slug-\u0418\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0441\u0442\u0440\u0430\u043d\u0438\u0446\u044b \u0434\u043b\u044f URL; \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u044b \u0441\u0438\u043c\u0432\u043e\u043b\u044b \u043b\u0430\u0442\u0438\u043d\u0438\u0446\u044b, \u0446\u0438\u0444\u0440\u044b, \u0434\u0435\u0444\u0438\u0441 \u0438 \u043f\u043e\u0434\u0447\u0451\u0440\u043a\u0438\u0432\u0430\u043d\u0438\u0435.] PASSED [ 91%]
tests/test_localization.py::test_help_text_translate[Post-pub_date-\u0415\u0441\u043b\u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u0438\u0442\u044c \u0434\u0430\u0442\u0443 \u0438 \u0432\u0440\u0435\u043c\u044f \u0432 \u0431\u0443\u0434\u0443\u0449\u0435\u043c \u2014 \u043c\u043e\u0436\u043d\u043e \u0434\u0435\u043b\u0430\u0442\u044c \u043e\u0442\u043b\u043e\u0436\u0435\u043d\u043d\u044b\u0435 \u043f\u0443\u0431\u043b\u0438\u043a\u0430\u0446\u0438\u0438.] PASSED [ 92%]
tests/test_location_model.py::TestLocationModelAttrs::test_model_attrs[name-CharField-params0] <- tests\conftest.py PASSED [ 93%]
tests/test_location_model.py::TestLocationModelAttrs::test_model_attrs[is_published-BooleanField-params1] <- tests\conftest.py PASSED [ 95%]
tests/test_location_model.py::TestLocationModelAttrs::test_model_attrs[created_at-DateTimeField-params2] <- tests\conftest.py PASSED [ 96%]
tests/test_urls.py::test_blog_urls PASSED                                [ 97%]
tests/test_urls.py::test_pages_urls PASSED                               [ 98%]
tests/test_urls.py::test_blogicum_urls PASSED                            [100%]

=================================== ERRORS ====================================
____________________ ERROR at setup of test_category_page _____________________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9AA64E0>
page_url = '/category/future-leader-final/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AA64E0>
path = '/category/future-leader-final/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AA64E0>
path = '/category/future-leader-final/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AA64E0>, method = 'GET'
path = '/category/future-leader-final/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/future-leader-final/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/future-leader-final/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AA64E0>
request = {'PATH_INFO': '/category/future-leader-final/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=vs6ejs39tcgr2gqn8wi2bxy4zymrob3h', 'PATH_INFO': '/category/future-leader-final/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025AB9B41AC0>, <django.template.base.Template object at 0x0000025AB8A83980>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588685233152'
exception_uid = 'request-exception-2588685233152'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AA64E0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/future-leader-final/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9AA45C0>
request = <WSGIRequest: GET '/category/future-leader-final/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/future-leader-final/'>
category_slug = 'future-leader-final'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/future-leader-final/'>
template_name = 'blog/category.html'
context = {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/future-leader-final/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB8A83170>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/future-leader-final/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9AFE450>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9AFE450>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9AFFDD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9B40680>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025AB9B40E00>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9B40C80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9B40C80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9B41AC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9B41AC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9B426C0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025AB9B42870>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025AB9B43560>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9B43170>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9B43170>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Agent Response Business Difference According Including>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9AA64E0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025AB9AA64E0>
page_url = '/category/future-leader-final/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9AA64E0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stdout setup ----------------------------
Operations to perform:
  Synchronize unmigrated apps: messages, staticfiles
  Apply all migrations: admin, auth, blog, contenttypes, sessions
Synchronizing apps without migrations:
  Creating tables...
    Running deferred SQL...
Running migrations:
  Applying contenttypes.0001_initial... OK
  Applying auth.0001_initial... OK
  Applying admin.0001_initial... OK
  Applying admin.0002_logentry_remove_auto_add... OK
  Applying admin.0003_logentry_add_action_flag_choices... OK
  Applying contenttypes.0002_remove_content_type_name... OK
  Applying auth.0002_alter_permission_name_max_length... OK
  Applying auth.0003_alter_user_email_max_length... OK
  Applying auth.0004_alter_user_username_opts... OK
  Applying auth.0005_alter_user_last_login_null... OK
  Applying auth.0006_require_contenttypes_0002... OK
  Applying auth.0007_alter_validators_add_error_messages... OK
  Applying auth.0008_alter_user_username_max_length... OK
  Applying auth.0009_alter_user_last_name_max_length... OK
  Applying auth.0010_alter_group_name_max_length... OK
  Applying auth.0011_update_proxy_permissions... OK
  Applying auth.0012_alter_user_first_name_max_length... OK
  Applying blog.0001_initial... OK
  Applying sessions.0001_initial... OK
---------------------------- Captured stderr setup ----------------------------
Creating test database for alias 'default' ('file:memorydb_default?mode=memory&cache=shared')...
Internal Server Error: /category/future-leader-final/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/future-leader-final/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_______ ERROR at setup of test_category_page_check_context_keys[title] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9AFD460>
page_url = '/category/good-figure-you/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AFD460>
path = '/category/good-figure-you/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AFD460>
path = '/category/good-figure-you/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AFD460>, method = 'GET'
path = '/category/good-figure-you/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/good-figure-you/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/good-figure-you/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AFD460>
request = {'PATH_INFO': '/category/good-figure-you/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=pgechqvkk53z9tr3l2a8ac5bwm8bqojn', 'PATH_INFO': '/category/good-figure-you/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025AB9D68650>, <django.template.base.Template object at 0x0000025AB9D51B50>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588692892928'
exception_uid = 'request-exception-2588692892928'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9AFD460>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/good-figure-you/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9AFD4F0>
request = <WSGIRequest: GET '/category/good-figure-you/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/good-figure-you/'>
category_slug = 'good-figure-you'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/good-figure-you/'>
template_name = 'blog/category.html'
context = {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/good-figure-you/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB9D50EC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/good-figure-you/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9D50200>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9D50200>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9D53110>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9D53A40>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025AB9D68530>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9D68320>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9D68320>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9D68650>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9D68650>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9D69250>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025AB9D694C0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025AB9D6A390>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9D69F40>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9D69F40>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: From Fund Job Ten Blood Modern>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9AFD460>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025AB9AFD460>
page_url = '/category/good-figure-you/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9AFD460>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/good-figure-you/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/good-figure-you/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
________ ERROR at setup of test_category_page_check_context_keys[key1] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9F828A0>
page_url = '/category/place-hair-final/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9F828A0>
path = '/category/place-hair-final/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9F828A0>
path = '/category/place-hair-final/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9F828A0>, method = 'GET'
path = '/category/place-hair-final/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/place-hair-final/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/place-hair-final/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9F828A0>
request = {'PATH_INFO': '/category/place-hair-final/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=krv30xrwhypfguqi795vsb7n1mc4m7cx', 'PATH_INFO': '/category/place-hair-final/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025AB9F6AB40>, <django.template.base.Template object at 0x0000025AB89E4800>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588695821952'
exception_uid = 'request-exception-2588695821952'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9F828A0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/place-hair-final/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9B427B0>
request = <WSGIRequest: GET '/category/place-hair-final/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/place-hair-final/'>
category_slug = 'place-hair-final'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/place-hair-final/'>
template_name = 'blog/category.html'
context = {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/place-hair-final/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB9F02AB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/place-hair-final/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB89E48C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB89E48C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9F69400>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9F69EE0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025AB9F6A9F0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9F6A7B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9F6A7B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9F6AB40>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9F6AB40>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9F6BAD0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025AB9F6BDA0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025AB9F20680>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9F23FB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9F23FB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Owner Tv Couple Network Ability New>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9F828A0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025AB9F828A0>
page_url = '/category/place-hair-final/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9F828A0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/place-hair-final/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/place-hair-final/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
________ ERROR at setup of test_category_page_check_context_keys[key2] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9ED9E20>
page_url = '/category/later-foot-writer/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9ED9E20>
path = '/category/later-foot-writer/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9ED9E20>
path = '/category/later-foot-writer/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9ED9E20>, method = 'GET'
path = '/category/later-foot-writer/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/later-foot-writer/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/later-foot-writer/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9ED9E20>
request = {'PATH_INFO': '/category/later-foot-writer/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=9ecnxuv9bi7uqqltclnqzowi98s1j4w8', 'PATH_INFO': '/category/later-foot-writer/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025AB8A2CA10>, <django.template.base.Template object at 0x0000025AB8A9B650>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588688536576'
exception_uid = 'request-exception-2588688536576'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9ED9E20>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/later-foot-writer/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9ED8080>
request = <WSGIRequest: GET '/category/later-foot-writer/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/later-foot-writer/'>
category_slug = 'later-foot-writer'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/later-foot-writer/'>
template_name = 'blog/category.html'
context = {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/later-foot-writer/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB8A9BAD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/later-foot-writer/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9F494C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9F494C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB8A649E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB8A2F8F0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025AB8A2F950>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB8A2DEE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB8A2DEE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB8A2CA10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB8A2CA10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB8A2F650>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025AB8A2F500>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025AB8A51D30>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9F71B80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9F71B80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Kid Later People Never Happen Resource>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9ED9E20>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025AB9ED9E20>
page_url = '/category/later-foot-writer/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9ED9E20>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/later-foot-writer/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/later-foot-writer/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
________ ERROR at setup of test_category_page_check_context_keys[key3] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9EAC500>
page_url = '/category/our-there-modern/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9EAC500>
path = '/category/our-there-modern/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9EAC500>
path = '/category/our-there-modern/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9EAC500>, method = 'GET'
path = '/category/our-there-modern/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/our-there-modern/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/our-there-modern/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9EAC500>
request = {'PATH_INFO': '/category/our-there-modern/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=socqsns3tj9ggunxcofqakx8d0cpqcag', 'PATH_INFO': '/category/our-there-modern/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA2707A0>, <django.template.base.Template object at 0x0000025AB9E99760>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588696460224'
exception_uid = 'request-exception-2588696460224'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9EAC500>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/our-there-modern/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9EAD1F0>
request = <WSGIRequest: GET '/category/our-there-modern/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/our-there-modern/'>
category_slug = 'our-there-modern'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/our-there-modern/'>
template_name = 'blog/category.html'
context = {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/our-there-modern/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB9F280B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/our-there-modern/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9EB53D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9EB53D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9E9AD20>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9E9B9E0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA270680>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA270470>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA270470>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA2707A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA2707A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA2713A0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA2715B0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA272390>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA271FA0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA271FA0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Read Account Suffer Home Source Person>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9EAC500>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025AB9EAC500>
page_url = '/category/our-there-modern/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025AB9EAC500>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/our-there-modern/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/our-there-modern/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
__________ ERROR at setup of test_category_page_category_unpublished __________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA2340E0>
page_url = '/category/bill-every-worker/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA2340E0>
path = '/category/bill-every-worker/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA2340E0>
path = '/category/bill-every-worker/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA2340E0>, method = 'GET'
path = '/category/bill-every-worker/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/bill-every-worker/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/bill-every-worker/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA2340E0>
request = {'PATH_INFO': '/category/bill-every-worker/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=i7g6f0702dtbta7zt1pa3h0v855tm503', 'PATH_INFO': '/category/bill-every-worker/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA19EF00>, <django.template.base.Template object at 0x0000025ABA1E8DA0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588696122816'
exception_uid = 'request-exception-2588696122816'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA2340E0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/bill-every-worker/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA236120>
request = <WSGIRequest: GET '/category/bill-every-worker/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/bill-every-worker/'>
category_slug = 'bill-every-worker'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/bill-every-worker/'>
template_name = 'blog/category.html'
context = {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/bill-every-worker/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA1CA630>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/bill-every-worker/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA1E2060>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA1E2060>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA19D670>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA19E180>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA19EDB0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA19EBA0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA19EBA0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA19EF00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA19EF00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA19FE30>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA226A20>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA19CD10>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA224800>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA224800>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Truth Admit Mrs Act Player Both>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA2340E0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA2340E0>
page_url = '/category/bill-every-worker/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA2340E0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/bill-every-worker/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/bill-every-worker/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
___________ ERROR at setup of test_category_page_posts_unpublished ____________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA227020>
page_url = '/category/laugh-six-reach/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA227020>
path = '/category/laugh-six-reach/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA227020>
path = '/category/laugh-six-reach/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA227020>, method = 'GET'
path = '/category/laugh-six-reach/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/laugh-six-reach/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/laugh-six-reach/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA227020>
request = {'PATH_INFO': '/category/laugh-six-reach/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=rjo1cydlb8p8cm2jtws7rv2acf0rpx3i', 'PATH_INFO': '/category/laugh-six-reach/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA3A2510>, <django.template.base.Template object at 0x0000025ABA28FB90>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588697902656'
exception_uid = 'request-exception-2588697902656'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA227020>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/laugh-six-reach/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA227E00>
request = <WSGIRequest: GET '/category/laugh-six-reach/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/laugh-six-reach/'>
category_slug = 'laugh-six-reach'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/laugh-six-reach/'>
template_name = 'blog/category.html'
context = {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/laugh-six-reach/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB8A53530>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/laugh-six-reach/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB89E79E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB89E79E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA3A0F50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA3A1850>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA3A23C0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA3A21B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA3A21B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA3A2510>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA3A2510>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA3A3110>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA3A3380>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA3F9400>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA3A3E90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA3A3E90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Left Fall Outside Item Nothing Commercial>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA227020>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA227020>
page_url = '/category/laugh-six-reach/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA227020>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/laugh-six-reach/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/laugh-six-reach/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
__________ ERROR at setup of test_category_page_pub_date_later_today __________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA40E330>
page_url = '/category/main-interesting/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA40E330>
path = '/category/main-interesting/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA40E330>
path = '/category/main-interesting/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA40E330>, method = 'GET'
path = '/category/main-interesting/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/main-interesting/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/main-interesting/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA40E330>
request = {'PATH_INFO': '/category/main-interesting/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=uamclgzczwqk6hs8zhcr2furbeevr3ls', 'PATH_INFO': '/category/main-interesting/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA42C950>, <django.template.base.Template object at 0x0000025ABA44AD20>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588698502400'
exception_uid = 'request-exception-2588698502400'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA40E330>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/main-interesting/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA462AE0>
request = <WSGIRequest: GET '/category/main-interesting/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/main-interesting/'>
category_slug = 'main-interesting'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/main-interesting/'>
template_name = 'blog/category.html'
context = {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/main-interesting/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA3CA420>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/main-interesting/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA285670>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA285670>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA3CBC80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA42DCD0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA42C7A0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA42C560>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA42C560>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA42C950>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA42C950>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA42D640>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA42DA00>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA42EC60>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA42E720>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA42E720>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Ask Try Close Person Large Eat>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA40E330>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA40E330>
page_url = '/category/main-interesting/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA40E330>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/main-interesting/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/main-interesting/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
__________ ERROR at setup of test_category_page_posts_with_location ___________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA3123F0>
page_url = '/category/cup-according/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA3123F0>
path = '/category/cup-according/', data = None, follow = False, secure = False
extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA3123F0>
path = '/category/cup-according/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA3123F0>, method = 'GET'
path = '/category/cup-according/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/cup-according/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/cup-according/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA3123F0>
request = {'PATH_INFO': '/category/cup-according/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=j9qper6uy16apat0vz5pcni0in3akfgu', 'PATH_INFO': '/category/cup-according/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA33CCB0>, <django.template.base.Template object at 0x0000025ABA3B1C10>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588699098752'
exception_uid = 'request-exception-2588699098752'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA3123F0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/cup-according/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA313950>
request = <WSGIRequest: GET '/category/cup-according/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/cup-according/'>
category_slug = 'cup-according'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/cup-according/'>
template_name = 'blog/category.html'
context = {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/cup-according/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA42EE10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/cup-according/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA3B1AF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA3B1AF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA30AE70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA30B7A0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA33CB00>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA33D6A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA33D6A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA33CCB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA33CCB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA33C3B0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA33C650>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA33E2A0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA33D6D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA33D6D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Tax Soon Whole Maybe Despite Foreign>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA3123F0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA3123F0>
page_url = '/category/cup-according/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA3123F0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/cup-according/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/cup-according/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
____ ERROR at setup of test_category_page_posts_with_unpublished_locations ____

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA302960>
page_url = '/category/discussion-center/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA302960>
path = '/category/discussion-center/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA302960>
path = '/category/discussion-center/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA302960>, method = 'GET'
path = '/category/discussion-center/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/discussion-center/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/discussion-center/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA302960>
request = {'PATH_INFO': '/category/discussion-center/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=jethnz5wnal74hkd75tct6zyyu17qbla', 'PATH_INFO': '/category/discussion-center/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA4CB320>, <django.template.base.Template object at 0x0000025ABA2E8DD0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588699753408'
exception_uid = 'request-exception-2588699753408'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA302960>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/discussion-center/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA303500>
request = <WSGIRequest: GET '/category/discussion-center/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/discussion-center/'>
category_slug = 'discussion-center'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/discussion-center/'>
template_name = 'blog/category.html'
context = {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/discussion-center/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB8A83290>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/discussion-center/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA2EA3C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA2EA3C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA4C9CA0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA4CA600>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA4CB170>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA4CAF60>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA4CAF60>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA4CB320>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA4CB320>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA4CBF20>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA4BB9B0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA4B8CE0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA4B8830>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA4B8830>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Price But Right Capital Wonder Simply>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA302960>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA302960>
page_url = '/category/discussion-center/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA302960>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/discussion-center/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/discussion-center/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_____________ ERROR at setup of test_many_posts_on_category_page ______________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA5045C0>
page_url = '/category/sign-score-still/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA5045C0>
path = '/category/sign-score-still/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA5045C0>
path = '/category/sign-score-still/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA5045C0>, method = 'GET'
path = '/category/sign-score-still/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/sign-score-still/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/sign-score-still/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA5045C0>
request = {'PATH_INFO': '/category/sign-score-still/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=558p2d8jqokahk4ex6h660rhhh3cmaya', 'PATH_INFO': '/category/sign-score-still/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA5870E0>, <django.template.base.Template object at 0x0000025ABA4D2A20>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588698970304'
exception_uid = 'request-exception-2588698970304'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA5045C0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/sign-score-still/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA507410>
request = <WSGIRequest: GET '/category/sign-score-still/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/sign-score-still/'>
category_slug = 'sign-score-still'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/sign-score-still/'>
template_name = 'blog/category.html'
context = {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/sign-score-still/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA580B90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/sign-score-still/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA4D30B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA4D30B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA585B80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA586480>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA586F30>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA586D20>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA586D20>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA5870E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA5870E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA587CE0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA587F20>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA56C830>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA56C1D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA56C1D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Eight Buy Property Often Pick Image>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA5045C0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA5045C0>
page_url = '/category/sign-score-still/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA5045C0>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/sign-score-still/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/sign-score-still/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
___________ ERROR at setup of test_no_other_posts_on_category_page ____________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA074B60>
page_url = '/category/continue-discussion/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA074B60>
path = '/category/continue-discussion/', data = None, follow = False
secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA074B60>
path = '/category/continue-discussion/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA074B60>, method = 'GET'
path = '/category/continue-discussion/', data = b''
content_type = 'application/octet-stream', secure = False
extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/category/continue-discussion/', params='', query='', fragment='')
r = {'PATH_INFO': '/category/continue-discussion/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA074B60>
request = {'PATH_INFO': '/category/continue-discussion/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=imlar2g03vhc88khvdz9n2gpn5gjnh53', 'PATH_INFO': '/category/continue-discussion/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025AB9FC6F00>, <django.template.base.Template object at 0x0000025ABA4D6060>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588699129728'
exception_uid = 'request-exception-2588699129728'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA074B60>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/continue-discussion/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA076F00>
request = <WSGIRequest: GET '/category/continue-discussion/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/continue-discussion/'>
category_slug = 'continue-discussion'

    def category_posts(request, category_slug):
        category = get_object_or_404(
            Category.objects.filter(is_published=True),
            slug=category_slug
        )
    
        post_list = Post.objects.filter(
            category=category,
            is_published=True,
            pub_date__lte=timezone.now()
        )
    
>       return render(
            request,
            'blog/category.html',
            {'category': category, 'post_list': post_list}
        )

blogicum\blog\views.py:40: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/category/continue-discussion/'>
template_name = 'blog/category.html'
context = {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/category.html'
context = {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/category/continue-discussion/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA584530>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/category/continue-discussion/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB8A2DE20>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB8A2DE20>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9FC58B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9FC6210>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025AB9FC6D80>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9FC6B70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9FC6B70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9FC6F00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9FC6F00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9FC7AD0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025AB9FC7D10>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025AB9FD49E0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9FD4500>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9FD4500>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'category': <Category: Into Through Century Would Rise Moment>, 'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA074B60>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)

tests\conftest.py:137: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA074B60>
page_url = '/category/continue-discussion/'
page_load_err_msg = 'Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст страницы категории передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA074B60>

    @pytest.fixture
    def category_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend(
            'blog.Post', is_published=True,
            category=temp_category, location=temp_location)
        page_load_err_msg = (
            'Убедитесь, что страница категории существует и отображается '
            'в соответствии с заданием в случае, '
            'если категория существует и опубликована.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст страницы категории передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, f'/category/{temp_category.slug}/',
                page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что страница категории существует и отображается в соответствии с заданием в случае, если категория существует и опубликована.

tests\conftest.py:141: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /category/continue-discussion/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /category/continue-discussion/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 40, in category_posts
    return render(
           ^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
___________ ERROR at setup of test_posts_page_pk_published_location ___________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9DA6C90>
post_with_published_location = <Post: Among Once Between Mention Plan Base>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9DA6C90>
path = '/posts/1/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9DA6C90>
path = '/posts/1/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9DA6C90>, method = 'GET'
path = '/posts/1/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/1/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9DA6C90>
request = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=ktzmjbvgs6swb4drs7xke4xwgwm6dwwr', 'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025AB9E7FE00>, <django.template.base.Template object at 0x0000025AB9DA7B00>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588697484352'
exception_uid = 'request-exception-2588697484352'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9DA6C90>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9DA6CF0>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, id = 1

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Among Once Between Mention Plan Base>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Among Once Between Mention Plan Base>}
request = <WSGIRequest: GET '/posts/1/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB9DA7AD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]
request = <WSGIRequest: GET '/posts/1/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9DA7EF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9DA7EF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9E7CD70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9E7F080>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025AB9E7FC20>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9E7FA10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9E7FA10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9E7FE00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9E7FE00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9E1CA70>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025AB9E1CD10>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025AB9E1DC10>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9E1D790>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025AB9E1D790>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Among Once Between Mention Plan Base>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9DA6C90>
post_with_published_location = <Post: Among Once Between Mention Plan Base>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
__________ ERROR at setup of test_posts_page_pk_unpublished_location __________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9E8FEC0>
post_with_published_location = <Post: Career Head American Determine Majority Produce>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9E8FEC0>
path = '/posts/2/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9E8FEC0>
path = '/posts/2/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9E8FEC0>, method = 'GET'
path = '/posts/2/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/2/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/2/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9E8FEC0>
request = {'PATH_INFO': '/posts/2/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=k05aq0nzsfkyv92tuys95v8kyvkdk57b', 'PATH_INFO': '/posts/2/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025AB9E6ABD0>, <django.template.base.Template object at 0x0000025AB9DFCA10>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588701829632'
exception_uid = 'request-exception-2588701829632'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9E8FEC0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/2/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9E8FE30>
request = <WSGIRequest: GET '/posts/2/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/2/'>, id = 2

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/2/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Career Head American Determine Majority Produce>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Career Head American Determine Majority Produce>}
request = <WSGIRequest: GET '/posts/2/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB9DFC0B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]
request = <WSGIRequest: GET '/posts/2/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9DFFCE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9DFFCE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9E68B90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025AB9E6ADE0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025AB9E6B920>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9E2B710>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025AB9E2B710>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9E6ABD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025AB9E6ABD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA8313D0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA832FC0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA8310A0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA830B30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA830B30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Career Head American Determine Majority Produce>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9E8FEC0>
post_with_published_location = <Post: Career Head American Determine Majority Produce>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/2/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/2/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_______ ERROR at setup of test_posts_page_pk_check_context_keys[title] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA7A3E30>
post_with_published_location = <Post: Few Play Account Relationship Improve Enter>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA7A3E30>
path = '/posts/1/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA7A3E30>
path = '/posts/1/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA7A3E30>, method = 'GET'
path = '/posts/1/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/1/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA7A3E30>
request = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=k1t32lq10mvv3pcu1slu191v00ypzrss', 'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA864380>, <django.template.base.Template object at 0x0000025ABA88D0D0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588703185728'
exception_uid = 'request-exception-2588703185728'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA7A3E30>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA7A3DA0>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, id = 1

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Few Play Account Relationship Improve Enter>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Few Play Account Relationship Improve Enter>}
request = <WSGIRequest: GET '/posts/1/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA84F950>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]
request = <WSGIRequest: GET '/posts/1/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA8000E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA8000E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA803860>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA8032C0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA7BC230>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA864080>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA864080>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA864380>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA864380>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA864FB0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA8651F0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA8660F0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA865C70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA865C70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Few Play Account Relationship Improve Enter>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA7A3E30>
post_with_published_location = <Post: Few Play Account Relationship Improve Enter>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
________ ERROR at setup of test_posts_page_pk_check_context_keys[text] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA77A8A0>
post_with_published_location = <Post: Dog Major Agent Population All Itself>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA77A8A0>
path = '/posts/1/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA77A8A0>
path = '/posts/1/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA77A8A0>, method = 'GET'
path = '/posts/1/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/1/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA77A8A0>
request = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=5kgpc5uvb6x35wov7rxf2a00vo11hl66', 'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA78B680>, <django.template.base.Template object at 0x0000025ABA8492E0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588700600640'
exception_uid = 'request-exception-2588700600640'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA77A8A0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA7784A0>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, id = 1

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Dog Major Agent Population All Itself>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Dog Major Agent Population All Itself>}
request = <WSGIRequest: GET '/posts/1/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA83F0B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]
request = <WSGIRequest: GET '/posts/1/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA88DF10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA88DF10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA788590>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA78A870>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA78B4D0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA78B200>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA78B200>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA78B680>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA78B680>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA708560>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA7887A0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA709520>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA789130>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA789130>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Dog Major Agent Population All Itself>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA77A8A0>
post_with_published_location = <Post: Dog Major Agent Population All Itself>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
________ ERROR at setup of test_posts_page_pk_check_context_keys[key2] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA70BDA0>
post_with_published_location = <Post: Skill Director Especially Book Pattern Never>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA70BDA0>
path = '/posts/1/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA70BDA0>
path = '/posts/1/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA70BDA0>, method = 'GET'
path = '/posts/1/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/1/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA70BDA0>
request = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=xuzveshf9b0rztbkv8mjxpz3il32kxxj', 'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA6FEFC0>, <django.template.base.Template object at 0x0000025ABA696CC0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588703882304'
exception_uid = 'request-exception-2588703882304'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA70BDA0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA70BD40>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, id = 1

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Skill Director Especially Book Pattern Never>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Skill Director Especially Book Pattern Never>}
request = <WSGIRequest: GET '/posts/1/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA74C200>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]
request = <WSGIRequest: GET '/posts/1/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA74CE30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA74CE30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA737FE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA6FE390>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA6FEEA0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA6FEC90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA6FEC90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA6FEFC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA6FEFC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA6FFBF0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA70FE00>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA16CCE0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA16C860>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA16C860>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Skill Director Especially Book Pattern Never>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA70BDA0>
post_with_published_location = <Post: Skill Director Especially Book Pattern Never>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
________ ERROR at setup of test_posts_page_pk_check_context_keys[key3] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA6FE300>
post_with_published_location = <Post: Style Friend Truth Skill Remember Call>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA6FE300>
path = '/posts/1/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA6FE300>
path = '/posts/1/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA6FE300>, method = 'GET'
path = '/posts/1/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/1/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA6FE300>
request = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=24dspmpjvvocr04axujfuagy5m9kelp5', 'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA1161B0>, <django.template.base.Template object at 0x0000025ABA121CD0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588701981760'
exception_uid = 'request-exception-2588701981760'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA6FE300>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA6FCBF0>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, id = 1

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Style Friend Truth Skill Remember Call>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Style Friend Truth Skill Remember Call>}
request = <WSGIRequest: GET '/posts/1/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA6FE690>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]
request = <WSGIRequest: GET '/posts/1/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA14BB90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA14BB90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA0B6120>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA115670>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA1160F0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA74DEE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA74DEE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA1161B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA1161B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA116DB0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA736FF0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA6FFE00>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA117950>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA117950>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Style Friend Truth Skill Remember Call>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA6FE300>
post_with_published_location = <Post: Style Friend Truth Skill Remember Call>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
________ ERROR at setup of test_posts_page_pk_check_context_keys[key4] ________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9FD12B0>
post_with_published_location = <Post: Peace Coach Within Pm Establish Minute>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9FD12B0>
path = '/posts/1/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9FD12B0>
path = '/posts/1/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9FD12B0>, method = 'GET'
path = '/posts/1/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/1/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9FD12B0>
request = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=qw1upasj0x3yb8f1t4p2hx3jutps5p1i', 'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA176FC0>, <django.template.base.Template object at 0x0000025ABA117320>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588705111872'
exception_uid = 'request-exception-2588705111872'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025AB9FD12B0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025AB9FD3560>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, id = 1

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Peace Coach Within Pm Establish Minute>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Peace Coach Within Pm Establish Minute>}
request = <WSGIRequest: GET '/posts/1/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA0CBBF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]
request = <WSGIRequest: GET '/posts/1/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA0BC7A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA0BC7A0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA0CD1F0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA0CF830>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA67D940>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA0CDD00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA0CDD00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA176FC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA176FC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA67CB90>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA70CDD0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA67DF10>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA67D880>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA67D880>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Peace Coach Within Pm Establish Minute>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025AB9FD12B0>
post_with_published_location = <Post: Peace Coach Within Pm Establish Minute>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_ ERROR at setup of test_posts_page_pk_post_with_published_location_and_category _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABAA12A50>
post_with_published_location = <Post: Management Crime Public Nature Debate Raise>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
>           post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')

tests\conftest.py:57: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA12A50>
path = '/posts/1/', data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA12A50>
path = '/posts/1/', data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA12A50>, method = 'GET'
path = '/posts/1/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/posts/1/', params='', query='', fragment='')
r = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA12A50>
request = {'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=487lmno1cnave9fepebjbz2bqhi76p3v', 'PATH_INFO': '/posts/1/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA9F5F70>, <django.template.base.Template object at 0x0000025ABAA76450>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588703233984'
exception_uid = 'request-exception-2588703233984'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA12A50>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABAA12F00>
request = <WSGIRequest: GET '/posts/1/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, id = 1

    def post_detail(request, id):
        post = get_object_or_404(
            Post.objects.filter(
                is_published=True,
                category__is_published=True,
                pub_date__lte=timezone.now()
            ),
            pk=id
        )
>       return render(request, 'blog/detail.html', {'post': post})

blogicum\blog\views.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/posts/1/'>, template_name = 'blog/detail.html'
context = {'post': <Post: Management Crime Public Nature Debate Raise>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/detail.html'
context = {'post': <Post: Management Crime Public Nature Debate Raise>}
request = <WSGIRequest: GET '/posts/1/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA67D460>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]
request = <WSGIRequest: GET '/posts/1/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA176270>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA176270>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAA770B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA9F5340>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA9F5DF0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA9F5C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA9F5C10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA9F5F70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA9F5F70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA9F6BA0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA9F6DB0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA9F7B90>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA9F7740>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA9F7740>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post': <Post: Management Crime Public Nature Debate Raise>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABAA12A50>
post_with_published_location = <Post: Management Crime Public Nature Debate Raise>

    @pytest.fixture
    def post_context_key(user_client, post_with_published_location):
        check_post_page_msg = (
            'Убедитесь, что страница публикации '
            'существует и отображается в соответствии с заданием.'
        )
        try:
            post_response = user_client.get(
                f'/posts/{post_with_published_location.id}/')
        except Exception:
>           raise AssertionError(check_post_page_msg)
E           AssertionError: Убедитесь, что страница публикации существует и отображается в соответствии с заданием.

tests\conftest.py:60: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /posts/1/
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 25, in post_detail
    return render(request, 'blog/detail.html', {'post': post})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
___________________ ERROR at setup of test_all_unpublished ____________________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA9CA540>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9CA540>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9CA540>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9CA540>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9CA540>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=ijar7wmua1ksfeaitnaliai9taq9zjbm', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA94E630>, <django.template.base.Template object at 0x0000025ABA9CA990>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588704851264'
exception_uid = 'request-exception-2588704851264'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9CA540>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA9CA4E0>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet []>}, content_type = None, status = None
using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html', context = {'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA9CAE40>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA9CA390>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA9CA390>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA94CFE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA94D940>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA94E480>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA94E270>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA94E270>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA94E630>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA94E630>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA94F230>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABA94F4A0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA998530>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA0BFEF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA0BFEF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA9CA540>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA9CA540>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA9CA540>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
___________________ ERROR at setup of test_mixed_published ____________________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA9C8050>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9C8050>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9C8050>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9C8050>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9C8050>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=5j9vl7prpdocc69hnvjazf3sli64zs70', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABA9612B0>, <django.template.base.Template object at 0x0000025ABA8CD730>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588707154880'
exception_uid = 'request-exception-2588707154880'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9C8050>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA9C9A90>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Here Southern Social Role Event Oil>, <Post: Improve Reduce Arrive Poor West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Here Southern Social Role Event Oil>, <Post: Improve Reduce Arrive Poor West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA8A2630>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA8CEA50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA8CEA50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA8CFBC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA960590>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABA9610D0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA960EC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA960EC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA9612B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA9612B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABA961EB0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABAA520F0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABA963080>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA962BD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABA962BD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Here Southern Social Role Event... West Partner>, <Post: Wonder Cover Sea Military Scene Store>, <Post: Interest Follow Exactly Director Their Claim>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA9C8050>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA9C8050>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA9C8050>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
______________ ERROR at setup of test_check_context_keys[title] _______________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA9EBB60>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9EBB60>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9EBB60>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9EBB60>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9EBB60>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=sma294i9t9oz6fzr2u8gjtl5fi47vngg', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABABFFA70>, <django.template.base.Template object at 0x0000025ABA5261E0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588701088768'
exception_uid = 'request-exception-2588701088768'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA9EBB60>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA893890>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Once There She More Show Possible>, <Post: Another Stay Will Management Establish Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Once There She More Show Possible>, <Post: Another Stay Will Management Establish Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA9883E0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA91D940>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA91D940>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABA963C80>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABABFEC30>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABABFF8C0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA94F6B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABA94F6B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABABFFA70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABABFFA70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAC081A0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABAC08440>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABAC09520>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAC08FE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAC08FE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Once There She More Show Possib...sh Week>, <Post: Year Prevent Daughter Friend Right Present>, <Post: Technology Attack After Year Involve Increase>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA9EBB60>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA9EBB60>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA9EBB60>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_______________ ERROR at setup of test_check_context_keys[key1] _______________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABAC4C380>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC4C380>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC4C380>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC4C380>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC4C380>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=1yfe2k9h5w0xof53vvffx3g9ncvf0f2l', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABAB3E8D0>, <django.template.base.Template object at 0x0000025ABAB94080>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588694911040'
exception_uid = 'request-exception-2588694911040'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC4C380>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABAC4DBB0>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Raise Health>, <Post: Its Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Raise Health>, <Post: Its Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025AB9E2A3C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB95A90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB95A90>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB3CD10>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAB3D760>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABAB3E600>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAB3E390>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAB3E390>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB3E8D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB3E8D0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAB3F560>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABAB3F800>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABAA907D0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAA90380>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAA90380>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Policy Century Detail Yeah Rais... Record Such Never Pick Hour>, <Post: Summer Mouth Either Less Choose Glass>, <Post: Those I Seven Might Food Fear>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAC4C380>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABAC4C380>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAC4C380>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_______________ ERROR at setup of test_check_context_keys[key2] _______________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABAA90DA0>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA90DA0>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA90DA0>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA90DA0>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA90DA0>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=hu79apcnq4p9tv7wh27cv20c5139sg3p', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABAAA94C0>, <django.template.base.Template object at 0x0000025ABAB17650>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588688322240'
exception_uid = 'request-exception-2588688322240'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAA90DA0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABAA91310>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Than>, <Post: Walk Policy Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Than>, <Post: Walk Policy Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABAAF2F30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB173B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB173B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAB17FE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAAA88F0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABAC09370>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAAA9190>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAAA9190>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAAA94C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAAA94C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAAAA0C0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABAAAA330>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABAAAB350>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAAAAEA0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAAAAEA0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Notice Onto Stage Best Late Tha... Put Ask Return Page>, <Post: Plan May Similar After Character Whose>, <Post: Guess Tell Agreement Remain Join Boy>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAA90DA0>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABAA90DA0>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAA90DA0>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_______________ ERROR at setup of test_check_context_keys[key3] _______________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABAADC290>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAADC290>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAADC290>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAADC290>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAADC290>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=7egtb1zq3w6l818w4gwej6gf6azg0qz7', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABB138200>, <django.template.base.Template object at 0x0000025ABB0EF650>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588699637120'
exception_uid = 'request-exception-2588699637120'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAADC290>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABAADD370>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Conference Exist Head Card Whose Nature>, <Post: Loss Player Anyone Politics Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Conference Exist Head Card Whose Nature>, <Post: Loss Player Anyone Politics Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABAB1C920>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB0F14C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB0F14C0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB0EEAB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABB0EF4D0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABB0EFFE0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABB0EFDD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABB0EFDD0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB138200>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB138200>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABB138E00>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABB139070>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABB139F10>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABB139AF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABB139AF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Conference Exist Head Card Whos...cs Science Network>, <Post: Speak Thank Other Difference Key Commercial>, <Post: Even Picture Out Partner Cut Card>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAADC290>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABAADC290>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAADC290>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_________________ ERROR at setup of test_category_unpublished _________________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABB0E6420>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABB0E6420>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABB0E6420>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABB0E6420>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABB0E6420>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=rfodosjrlvjlrpmj8d753dc59z8pt6lf', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABB101EE0>, <django.template.base.Template object at 0x0000025ABB13A060>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588711248960'
exception_uid = 'request-exception-2588711248960'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABB0E6420>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABB0E46B0>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet []>}, content_type = None, status = None
using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html', context = {'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABB10A720>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB13B350>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB13B350>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB100650>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABB101040>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABB109CD0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABB101AF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABB101AF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB101EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB101EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABB102BD0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABB102EA0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABADEC260>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABB10BE30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABB10BE30>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABB0E6420>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABB0E6420>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABB0E6420>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_________________ ERROR at setup of test_pub_date_later_today _________________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABA8CE330>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA8CE330>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA8CE330>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA8CE330>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA8CE330>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=jxvg2uhlgcqyv3a26zr86kswkqkshg23', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABAE68350>, <django.template.base.Template object at 0x0000025ABAE76AE0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588709843968'
exception_uid = 'request-exception-2588709843968'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABA8CE330>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABA8CD4C0>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet []>}, content_type = None, status = None
using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html', context = {'post_list': <QuerySet []>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABAE76630>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE75DF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE75DF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE77290>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAE77C80>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABAE681A0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAE6A510>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAE6A510>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE68350>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE68350>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAE690D0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABAE692E0>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABAE6A5D0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAE69EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAE69EE0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet []>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA8CE330>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABA8CE330>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABA8CE330>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
____________ ERROR at setup of test_posts_with_published_location _____________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABAE7FE60>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAE7FE60>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAE7FE60>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAE7FE60>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAE7FE60>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=s0aemdj8lkpj08fzl9b6efapocrztwaq', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABAE5F9B0>, <django.template.base.Template object at 0x0000025ABADB1A60>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588693347456'
exception_uid = 'request-exception-2588693347456'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAE7FE60>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABAE7CE90>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Group Throw>, <Post: Language Though Institution Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Group Throw>, <Post: Language Though Institution Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABAE02ED0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE5CE00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE5CE00>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE5E240>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAE5EC30>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABAE5F7D0>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAE5F5F0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAE5F5F0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE5F9B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAE5F9B0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAD27E60>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABAD24110>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABAD252B0>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAD24CB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAD24CB0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Never Represent Heart Enjoy Gro...Feel Respond Share>, <Post: Nor Organization Gas Edge Because Community>, <Post: Teacher Son Herself Thus Body Key>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAE7FE60>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABAE7FE60>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAE7FE60>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
___________ ERROR at setup of test_posts_with_unpublished_locations ___________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABACABEF0>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABACABEF0>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABACABEF0>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABACABEF0>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABACABEF0>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=aqatbkk7ocg30p0mier5pt76xqfj2kwl', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABAD72600>, <django.template.base.Template object at 0x0000025ABAD67A70>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588700406272'
exception_uid = 'request-exception-2588700406272'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABACABEF0>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABACABEC0>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Adult Available Suffer Between Response Purpose>, <Post: Drug Since Certainly None Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Adult Available Suffer Between Response Purpose>, <Post: Drug Since Certainly None Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABA7E5DC0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAD0DC70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAD0DC70>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAD70EF0>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAD71880>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABAD72450>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAD72240>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABAD72240>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAD72600>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAD72600>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABAD735C0>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABAD73920>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABAD00560>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAC99820>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABAC99820>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Adult Available Suffer Between ...one Involve Against>, <Post: East Also Start Early Life Democrat>, <Post: Window Every Political Summer Reason Gun>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABACABEF0>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABACABEF0>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABACABEF0>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
_______________ ERROR at setup of test_many_posts_on_main_page ________________

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
>                   extra, resolver = resolver.namespace_dict[ns]
E                   KeyError: 'pages'

venv\Lib\site-packages\django\urls\base.py:71: KeyError

During handling of the above exception, another exception occurred:

user_client = <django.test.client.Client object at 0x0000025ABAC9B110>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
>           post_response = user_client.get(page_url)

tests\conftest.py:76: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC9B110>, path = '/'
data = None, follow = False, secure = False, extra = {}

    def get(self, path, data=None, follow=False, secure=False, **extra):
        """Request a response from the server using GET."""
        self.extra = extra
>       response = super().get(path, data=data, secure=secure, **extra)

venv\Lib\site-packages\django\test\client.py:742: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC9B110>, path = '/'
data = {}, secure = False, extra = {}

    def get(self, path, data=None, secure=False, **extra):
        """Construct a GET request."""
        data = {} if data is None else data
>       return self.generic('GET', path, secure=secure, **{
            'QUERY_STRING': urlencode(data, doseq=True),
            **extra,
        })

venv\Lib\site-packages\django\test\client.py:396: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC9B110>, method = 'GET'
path = '/', data = b'', content_type = 'application/octet-stream'
secure = False, extra = {'QUERY_STRING': ''}
parsed = ParseResult(scheme='', netloc='', path='/', params='', query='', fragment='')
r = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
query_string = ''

    def generic(self, method, path, data='',
                content_type='application/octet-stream', secure=False,
                **extra):
        """Construct an arbitrary HTTP request."""
        parsed = urlparse(str(path))  # path can be lazy
        data = force_bytes(data, settings.DEFAULT_CHARSET)
        r = {
            'PATH_INFO': self._get_path(parsed),
            'REQUEST_METHOD': method,
            'SERVER_PORT': '443' if secure else '80',
            'wsgi.url_scheme': 'https' if secure else 'http',
        }
        if data:
            r.update({
                'CONTENT_LENGTH': str(len(data)),
                'CONTENT_TYPE': content_type,
                'wsgi.input': FakePayload(data),
            })
        r.update(extra)
        # If QUERY_STRING is absent or empty, we want to extract it from the URL.
        if not r.get('QUERY_STRING'):
            # WSGI requires latin-1 encoded strings. See get_path_info().
            query_string = parsed[4].encode().decode('iso-8859-1')
            r['QUERY_STRING'] = query_string
>       return self.request(**r)

venv\Lib\site-packages\django\test\client.py:473: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC9B110>
request = {'PATH_INFO': '/', 'QUERY_STRING': '', 'REQUEST_METHOD': 'GET', 'SERVER_PORT': '80', ...}
environ = {'HTTP_COOKIE': 'sessionid=duuffvq1dfpca2xxzbdh4dygh5wg29bd', 'PATH_INFO': '/', 'QUERY_STRING': '', 'REMOTE_ADDR': '127.0.0.1', ...}
data = {'context': [[{'True': True, 'False': False, 'None': None}, {'csrf_token': <SimpleLazyObject: <function csrf.<locals>....go.template.base.Template object at 0x0000025ABB312600>, <django.template.base.Template object at 0x0000025ABAE691C0>]}
on_template_render = functools.partial(<function store_rendered_templates at 0x0000025AB887A2A0>, {'templates': [<django.template.base.Temp... '', '    return resolver._reverse_with_prefix(view, prefix, *args, **kwargs)', '', ''], 'pre_context_lineno': 75}}]]})
signal_uid = 'template-render-2588701749632'
exception_uid = 'request-exception-2588701749632'
response = <HttpResponse status_code=500, "text/html">

    def request(self, **request):
        """
        The master request method. Compose the environment dictionary and pass
        to the handler, return the result of the handler. Assume defaults for
        the query environment, which can be overridden using the arguments to
        the request.
        """
        environ = self._base_environ(**request)
    
        # Curry a data dictionary into an instance of the template renderer
        # callback function.
        data = {}
        on_template_render = partial(store_rendered_templates, data)
        signal_uid = "template-render-%s" % id(request)
        signals.template_rendered.connect(on_template_render, dispatch_uid=signal_uid)
        # Capture exceptions created by the handler.
        exception_uid = "request-exception-%s" % id(request)
        got_request_exception.connect(self.store_exc_info, dispatch_uid=exception_uid)
        try:
            response = self.handler(environ)
        finally:
            signals.template_rendered.disconnect(dispatch_uid=signal_uid)
            got_request_exception.disconnect(dispatch_uid=exception_uid)
        # Check for signaled exceptions.
>       self.check_exception(response)

venv\Lib\site-packages\django\test\client.py:719: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.Client object at 0x0000025ABAC9B110>
response = <HttpResponse status_code=500, "text/html">

    def check_exception(self, response):
        """
        Look for a signaled exception, clear the current context exception
        data, re-raise the signaled exception, and clear the signaled exception
        from the local cache.
        """
        response.exc_info = self.exc_info
        if self.exc_info:
            _, exc_value, _ = self.exc_info
            self.exc_info = None
            if self.raise_request_exception:
>               raise exc_value

venv\Lib\site-packages\django\test\client.py:580: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    @wraps(get_response)
    def inner(request):
        try:
>           response = get_response(request)

venv\Lib\site-packages\django\core\handlers\exception.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.test.client.ClientHandler object at 0x0000025ABAC9BC80>
request = <WSGIRequest: GET '/'>

    def _get_response(self, request):
        """
        Resolve and call the view, then apply view, exception, and
        template_response middleware. This method is everything that happens
        inside the request/response middleware.
        """
        response = None
        callback, callback_args, callback_kwargs = self.resolve_request(request)
    
        # Apply view middleware
        for middleware_method in self._view_middleware:
            response = middleware_method(request, callback, callback_args, callback_kwargs)
            if response:
                break
    
        if response is None:
            wrapped_callback = self.make_view_atomic(callback)
            # If it is an asynchronous view, run it in a subthread.
            if asyncio.iscoroutinefunction(wrapped_callback):
                wrapped_callback = async_to_sync(wrapped_callback)
            try:
>               response = wrapped_callback(request, *callback_args, **callback_kwargs)

venv\Lib\site-packages\django\core\handlers\base.py:181: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>

    def index(request):
        post_list = Post.objects.filter(
            is_published=True,
            category__is_published=True,
            pub_date__lte=timezone.now()
        ).order_by('-pub_date')[:5]
    
>       return render(request, 'blog/index.html', {'post_list': post_list})

blogicum\blog\views.py:13: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

request = <WSGIRequest: GET '/'>, template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Development Exist Process College Scene Lead>, <Post: Can Both Either Artist Explain L...d End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}
content_type = None, status = None, using = None

    def render(request, template_name, context=None, content_type=None, status=None, using=None):
        """
        Return a HttpResponse whose content is filled with the result of calling
        django.template.loader.render_to_string() with the passed arguments.
        """
>       content = loader.render_to_string(template_name, context, request, using=using)

venv\Lib\site-packages\django\shortcuts.py:19: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

template_name = 'blog/index.html'
context = {'post_list': <QuerySet [<Post: Development Exist Process College Scene Lead>, <Post: Can Both Either Artist Explain L...d End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}
request = <WSGIRequest: GET '/'>, using = None

    def render_to_string(template_name, context=None, request=None, using=None):
        """
        Load a template and render it with a context. Return a string.
    
        template_name may be a string or a list of strings.
        """
        if isinstance(template_name, (list, tuple)):
            template = select_template(template_name, using=using)
        else:
            template = get_template(template_name, using=using)
>       return template.render(context, request)

venv\Lib\site-packages\django\template\loader.py:62: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.backends.django.Template object at 0x0000025ABB292900>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]
request = <WSGIRequest: GET '/'>

    def render(self, context=None, request=None):
        context = make_context(context, request, autoescape=self.backend.engine.autoescape)
        try:
>           return self.template.render(context)

venv\Lib\site-packages\django\template\backends\django.py:61: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAD17260>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
>                   return self._render(context)

venv\Lib\site-packages\django\template\base.py:170: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABAD17260>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<ExtendsNode: extends "base.html">]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <ExtendsNode: extends "base.html">
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        compiled_parent = self.get_parent(context)
    
        if BLOCK_CONTEXT_KEY not in context.render_context:
            context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
        block_context = context.render_context[BLOCK_CONTEXT_KEY]
    
        # Add the block nodes from this node to the block context
        block_context.add_blocks(self.blocks)
    
        # If this block's parent doesn't have an extends node it is the root,
        # and its block nodes also need to be added to the block context.
        for node in compiled_parent.nodelist:
            # The ExtendsNode has to be the first non-text node.
            if not isinstance(node, TextNode):
                if not isinstance(node, ExtendsNode):
                    blocks = {n.name: n for n in
                              compiled_parent.nodelist.get_nodes_by_type(BlockNode)}
                    block_context.add_blocks(blocks)
                break
    
        # Call Template._render explicitly so the parser context stays
        # the same.
        with context.render_context.push_state(compiled_parent, isolated_context=False):
>           return compiled_parent._render(context)

venv\Lib\site-packages\django\template\loader_tags.py:150: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB311100>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABB3119A0>, <TextNode: '\n<!DOCTYPE html>\n<html la'>, <djan...main>'>, <django.template.loader_tags.IncludeNode object at 0x0000025ABB312480>, <TextNode: '   \n  </body>\n</html>'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABB312270>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.loader_tags.IncludeNode object at 0x0000025ABB312270>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        """
        Render the specified template and context. Cache the template object
        in render_context to avoid reparsing and loading when used in a for
        loop.
        """
        template = self.template.resolve(context)
        # Does this quack like a Template?
        if not callable(getattr(template, 'render', None)):
            # If not, try the cache and select_template().
            template_name = template or ()
            if isinstance(template_name, str):
                template_name = (construct_relative_path(
                    self.origin.template_name,
                    template_name,
                ),)
            else:
                template_name = tuple(template_name)
            cache = context.render_context.dicts[0].setdefault(self, {})
            template = cache.get(template_name)
            if template is None:
                template = context.template.engine.select_template(template_name)
                cache[template_name] = template
        # Use the base.Template of a backends.django.Template.
        elif hasattr(template, 'template'):
            template = template.template
        values = {
            name: var.resolve(context)
            for name, var in self.extra_context.items()
        }
        if self.isolated_context:
            return template.render(context.new(values))
        with context.push(**values):
>           return template.render(context)

venv\Lib\site-packages\django\template\loader_tags.py:195: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB312600>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        "Display stage -- can be called many times"
        with context.render_context.push_state(self):
            if context.template is None:
                with context.bind_template(self):
                    context.template_name = self.name
                    return self._render(context)
            else:
>               return self._render(context)

venv\Lib\site-packages\django\template\base.py:172: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.base.Template object at 0x0000025ABB312600>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def instrumented_test_render(self, context):
        """
        An instrumented Template render method, providing a signal that can be
        intercepted by the test Client.
        """
        template_rendered.send(sender=self, template=self, context=context)
>       return self.nodelist.render(context)

venv\Lib\site-packages\django\test\utils.py:100: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<django.template.defaulttags.LoadNode object at 0x0000025ABB313200>, <TextNode: '\n<header>\n  <nav class="n'>, <djan...at 0x0000025ABB313440>, <TextNode: '" width="30" height="30" '>, <WithNode>, <TextNode: '      \n    </div>\n  </nav'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <WithNode>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        values = {key: val.resolve(context) for key, val in self.extra_context.items()}
        with context.push(**values):
>           return self.nodelist.render(context)

venv\Lib\site-packages\django\template\defaulttags.py:519: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = [<TextNode: '        \n        <ul clas'>, <IfNode>, <TextNode: '" href="'>, <django.template.defaulttags.URLNode obje...href="'>, <django.template.defaulttags.URLNode object at 0x0000025ABB311B50>, <TextNode: '">\n              Наши пра'>]
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        bits = []
        for node in self:
            if isinstance(node, Node):
>               bit = node.render_annotated(context)

venv\Lib\site-packages\django\template\base.py:938: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABB313F50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render_annotated(self, context):
        """
        Render the node. If debug is True and an exception occurs during
        rendering, the exception is annotated with contextual line information
        where it occurred in the template. For internal usage this method is
        preferred over using the render method directly.
        """
        try:
>           return self.render(context)

venv\Lib\site-packages\django\template\base.py:905: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <django.template.defaulttags.URLNode object at 0x0000025ABB313F50>
context = [{'True': True, 'False': False, 'None': None}, {}, {}, {'post_list': <QuerySet [<Post: Development Exist Process Colle... End New Issue Scientist>, <Post: Career Think May I Beyond Increase>, <Post: Claim Game Indeed Arrive Think Avoid>]>}]

    def render(self, context):
        from django.urls import NoReverseMatch, reverse
        args = [arg.resolve(context) for arg in self.args]
        kwargs = {k: v.resolve(context) for k, v in self.kwargs.items()}
        view_name = self.view_name.resolve(context)
        try:
            current_app = context.request.current_app
        except AttributeError:
            try:
                current_app = context.request.resolver_match.namespace
            except AttributeError:
                current_app = None
        # Try to look up the URL. If it fails, raise NoReverseMatch unless the
        # {% url ... as var %} construct is used, in which case return nothing.
        url = ''
        try:
>           url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)

venv\Lib\site-packages\django\template\defaulttags.py:449: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

viewname = 'pages:about', urlconf = 'blogicum.urls', args = [], kwargs = {}
current_app = 'blog'

    def reverse(viewname, urlconf=None, args=None, kwargs=None, current_app=None):
        if urlconf is None:
            urlconf = get_urlconf()
        resolver = get_resolver(urlconf)
        args = args or []
        kwargs = kwargs or {}
    
        prefix = get_script_prefix()
    
        if not isinstance(viewname, str):
            view = viewname
        else:
            *path, view = viewname.split(':')
    
            if current_app:
                current_path = current_app.split(':')
                current_path.reverse()
            else:
                current_path = None
    
            resolved_path = []
            ns_pattern = ''
            ns_converters = {}
            for ns in path:
                current_ns = current_path.pop() if current_path else None
                # Lookup the name to see if it could be an app identifier.
                try:
                    app_list = resolver.app_dict[ns]
                    # Yes! Path part matches an app in the current Resolver.
                    if current_ns and current_ns in app_list:
                        # If we are reversing for a particular app, use that
                        # namespace.
                        ns = current_ns
                    elif ns not in app_list:
                        # The name isn't shared by one of the instances (i.e.,
                        # the default) so pick the first instance as the default.
                        ns = app_list[0]
                except KeyError:
                    pass
    
                if ns != current_ns:
                    current_path = None
    
                try:
                    extra, resolver = resolver.namespace_dict[ns]
                    resolved_path.append(ns)
                    ns_pattern = ns_pattern + extra
                    ns_converters.update(resolver.pattern.converters)
                except KeyError as key:
                    if resolved_path:
                        raise NoReverseMatch(
                            "%s is not a registered namespace inside '%s'" %
                            (key, ':'.join(resolved_path))
                        )
                    else:
>                       raise NoReverseMatch("%s is not a registered namespace" % key)
E                       django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace

venv\Lib\site-packages\django\urls\base.py:82: NoReverseMatch

During handling of the above exception, another exception occurred:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAC9B110>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
>           result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)

tests\conftest.py:108: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

user_client = <django.test.client.Client object at 0x0000025ABAC9B110>
page_url = '/'
page_load_err_msg = 'Убедитесь, что главная страница существует и отображается в соответствии с заданием.'
key_missing_msg = 'Убедитесь, что если существует хотя бы один опубликованный пост с опубликованной категорией и датой публикации в прошлом, в контекст главной страницы передаётся непустой список постов.'

    def get_post_list_context_key(
            user_client, page_url, page_load_err_msg, key_missing_msg):
        try:
            post_response = user_client.get(page_url)
        except Exception:
>           raise AssertionError(page_load_err_msg)
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:78: AssertionError

The above exception was the direct cause of the following exception:

mixer = <Mixer [fake]>
user_client = <django.test.client.Client object at 0x0000025ABAC9B110>

    @pytest.fixture
    def main_page_post_list_context_key(mixer, user_client):
        temp_category = mixer.blend('blog.Category', is_published=True)
        temp_location = mixer.blend('blog.Location', is_published=True)
        temp_post = mixer.blend('blog.Post', is_published=True,
                                location=temp_location, category=temp_category)
        page_load_err_msg = (
            'Убедитесь, что главная страница существует и отображается '
            'в соответствии с заданием.'
        )
        key_missing_msg = (
            'Убедитесь, что если существует хотя бы один опубликованный пост '
            'с опубликованной категорией и датой публикации в прошлом, '
            'в контекст главной страницы передаётся непустой список постов.'
        )
        try:
            result = get_post_list_context_key(
                user_client, '/', page_load_err_msg, key_missing_msg)
        except Exception as e:
>           raise AssertionError(str(e)) from e
E           AssertionError: Убедитесь, что главная страница существует и отображается в соответствии с заданием.

tests\conftest.py:111: AssertionError
---------------------------- Captured stderr setup ----------------------------
Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
----------------------------- Captured log setup ------------------------------
ERROR    django.request:log.py:224 Internal Server Error: /
Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 71, in reverse
    extra, resolver = resolver.namespace_dict[ns]
                      ~~~~~~~~~~~~~~~~~~~~~~~^^^^
KeyError: 'pages'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\exception.py", line 47, in inner
    response = get_response(request)
               ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\core\handlers\base.py", line 181, in _get_response
    response = wrapped_callback(request, *callback_args, **callback_kwargs)
               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\blogicum\blog\views.py", line 13, in index
    return render(request, 'blog/index.html', {'post_list': post_list})
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\shortcuts.py", line 19, in render
    content = loader.render_to_string(template_name, context, request, using=using)
              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader.py", line 62, in render_to_string
    return template.render(context, request)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\backends\django.py", line 61, in render
    return self.template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 170, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 150, in render
    return compiled_parent._render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\loader_tags.py", line 195, in render
    return template.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 172, in render
    return self._render(context)
           ^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\test\utils.py", line 100, in instrumented_test_render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 519, in render
    return self.nodelist.render(context)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 938, in render
    bit = node.render_annotated(context)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\base.py", line 905, in render_annotated
    return self.render(context)
           ^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\template\defaulttags.py", line 449, in render
    url = reverse(view_name, args=args, kwargs=kwargs, current_app=current_app)
          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\Yandex\sprint3\django_sprint3\venv\Lib\site-packages\django\urls\base.py", line 82, in reverse
    raise NoReverseMatch("%s is not a registered namespace" % key)
django.urls.exceptions.NoReverseMatch: 'pages' is not a registered namespace
================================== FAILURES ===================================
__________________________ test_pageapp_views[about] __________________________

user_client = <django.test.client.Client object at 0x0000025ABA05CF50>
page = 'about'

    @pytest.mark.parametrize('page', ('about', 'rules'))
    @pytest.mark.django_db
    def test_pageapp_views(user_client, page):
        response = user_client.get(f'/pages/{page}/')
>       assert response.status_code == HTTPStatus.OK, (
            f'Убедитесь, что страница `/pages/{page}/` существует и отображается '
            'в соответствии с заданием.'
        )
E       AssertionError: Убедитесь, что страница `/pages/about/` существует и отображается в соответствии с заданием.
E       assert 404 == <HTTPStatus.OK: 200>
E        +  where 404 = <HttpResponseNotFound status_code=404, "text/html">.status_code
E        +  and   <HTTPStatus.OK: 200> = HTTPStatus.OK

tests\test_pageapp_views.py:11: AssertionError
---------------------------- Captured stderr call -----------------------------
Not Found: /pages/about/
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Not Found: /pages/about/
__________________________ test_pageapp_views[rules] __________________________

user_client = <django.test.client.Client object at 0x0000025AB9E2A000>
page = 'rules'

    @pytest.mark.parametrize('page', ('about', 'rules'))
    @pytest.mark.django_db
    def test_pageapp_views(user_client, page):
        response = user_client.get(f'/pages/{page}/')
>       assert response.status_code == HTTPStatus.OK, (
            f'Убедитесь, что страница `/pages/{page}/` существует и отображается '
            'в соответствии с заданием.'
        )
E       AssertionError: Убедитесь, что страница `/pages/rules/` существует и отображается в соответствии с заданием.
E       assert 404 == <HTTPStatus.OK: 200>
E        +  where 404 = <HttpResponseNotFound status_code=404, "text/html">.status_code
E        +  and   <HTTPStatus.OK: 200> = HTTPStatus.OK

tests\test_pageapp_views.py:11: AssertionError
---------------------------- Captured stderr call -----------------------------
Not Found: /pages/rules/
------------------------------ Captured log call ------------------------------
WARNING  django.request:log.py:224 Not Found: /pages/rules/
=========================== short test summary info ===========================
FAILED tests/test_pageapp_views.py::test_pageapp_views[about] - AssertionErro...
FAILED tests/test_pageapp_views.py::test_pageapp_views[rules] - AssertionErro...
ERROR tests/test_category_page_views.py::test_category_page - AssertionError:...
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[title]
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[key1]
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[key2]
ERROR tests/test_category_page_views.py::test_category_page_check_context_keys[key3]
ERROR tests/test_category_page_views.py::test_category_page_category_unpublished
ERROR tests/test_category_page_views.py::test_category_page_posts_unpublished
ERROR tests/test_category_page_views.py::test_category_page_pub_date_later_today
ERROR tests/test_category_page_views.py::test_category_page_posts_with_location
ERROR tests/test_category_page_views.py::test_category_page_posts_with_unpublished_locations
ERROR tests/test_category_page_views.py::test_many_posts_on_category_page - A...
ERROR tests/test_category_page_views.py::test_no_other_posts_on_category_page
ERROR tests/test_post_detail_views.py::test_posts_page_pk_published_location
ERROR tests/test_post_detail_views.py::test_posts_page_pk_unpublished_location
ERROR tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[title]
ERROR tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[text]
ERROR tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key2]
ERROR tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key3]
ERROR tests/test_post_detail_views.py::test_posts_page_pk_check_context_keys[key4]
ERROR tests/test_post_detail_views.py::test_posts_page_pk_post_with_published_location_and_category
ERROR tests/test_posts_page_views.py::test_all_unpublished - AssertionError: ...
ERROR tests/test_posts_page_views.py::test_mixed_published - AssertionError: ...
ERROR tests/test_posts_page_views.py::test_check_context_keys[title] - Assert...
ERROR tests/test_posts_page_views.py::test_check_context_keys[key1] - Asserti...
ERROR tests/test_posts_page_views.py::test_check_context_keys[key2] - Asserti...
ERROR tests/test_posts_page_views.py::test_check_context_keys[key3] - Asserti...
ERROR tests/test_posts_page_views.py::test_category_unpublished - AssertionEr...
ERROR tests/test_posts_page_views.py::test_pub_date_later_today - AssertionEr...
ERROR tests/test_posts_page_views.py::test_posts_with_published_location - As...
ERROR tests/test_posts_page_views.py::test_posts_with_unpublished_locations
ERROR tests/test_posts_page_views.py::test_many_posts_on_main_page - Assertio...
============ 2 failed, 49 passed, 842 warnings, 31 errors in 9.59s ============
